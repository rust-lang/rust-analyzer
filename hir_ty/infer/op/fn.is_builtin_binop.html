<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Returns `true` if this is a built-in arithmetic operation (e.g., u32 + u32, i16x4 == i16x4) and false if these types would have to be overloaded to be legal. There are two reasons that we distinguish builtin operations from overloaded ones (vs trying to drive everything uniformly through the trait system and intrinsics or something like that):"><title>is_builtin_binop in hir_ty::infer::op - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="hir_ty" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.1 (01f6ddf75 2026-02-11)" data-channel="1.93.1" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">is_builtin_binop</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../hir_ty/index.html">hir_ty</a><span class="version">0.0.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In hir_<wbr>ty::<wbr>infer::<wbr>op</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">hir_ty</a>::<wbr><a href="../index.html">infer</a>::<wbr><a href="index.html">op</a></div><h1>Function <span class="fn">is_<wbr>builtin_<wbr>binop</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/hir_ty/infer/op.rs.html#454-473">Source</a> </span></div><pre class="rust item-decl"><code>fn is_builtin_binop&lt;'db&gt;(
    lhs: <a class="struct" href="../../next_solver/struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;,
    rhs: <a class="struct" href="../../next_solver/struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;,
    category: <a class="enum" href="enum.BinOpCategory.html" title="enum hir_ty::infer::op::BinOpCategory">BinOpCategory</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.bool.html">bool</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Returns <code>true</code> if this is a built-in arithmetic operation (e.g.,
u32 + u32, i16x4 == i16x4) and false if these types would have to be
overloaded to be legal. There are two reasons that we distinguish
builtin operations from overloaded ones (vs trying to drive
everything uniformly through the trait system and intrinsics or
something like that):</p>
<ol>
<li>Builtin operations can trivially be evaluated in constants.</li>
<li>For comparison operators applied to SIMD types the result is
not of type <code>bool</code>. For example, <code>i16x4 == i16x4</code> yields a
type like <code>i16x4</code>. This means that the overloaded trait
<code>PartialEq</code> is not applicable.</li>
</ol>
<p>Reason #2 is the killer. I tried for a while to always use
overloaded logic and just check the types in constants/codegen after
the fact, and it worked fine, except for SIMD types. -nmatsakis</p>
</div></details></section></div></main></body></html>