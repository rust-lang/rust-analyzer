<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `TyKind` type in crate `hir_ty`."><title>TyKind in hir_ty::next_solver - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hir_ty" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.1 (01f6ddf75 2026-02-11)" data-channel="1.93.1" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">TyKind</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hir_ty/index.html">hir_ty</a><span class="version">0.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">TyKind</a></h2><h3><a href="#aliased-type">Aliased Type</a></h3><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.Adt" title="Adt">Adt</a></li><li><a href="#variant.Alias" title="Alias">Alias</a></li><li><a href="#variant.Array" title="Array">Array</a></li><li><a href="#variant.Bool" title="Bool">Bool</a></li><li><a href="#variant.Bound" title="Bound">Bound</a></li><li><a href="#variant.Char" title="Char">Char</a></li><li><a href="#variant.Closure" title="Closure">Closure</a></li><li><a href="#variant.Coroutine" title="Coroutine">Coroutine</a></li><li><a href="#variant.CoroutineClosure" title="CoroutineClosure">CoroutineClosure</a></li><li><a href="#variant.CoroutineWitness" title="CoroutineWitness">CoroutineWitness</a></li><li><a href="#variant.Dynamic" title="Dynamic">Dynamic</a></li><li><a href="#variant.Error" title="Error">Error</a></li><li><a href="#variant.Float" title="Float">Float</a></li><li><a href="#variant.FnDef" title="FnDef">FnDef</a></li><li><a href="#variant.FnPtr" title="FnPtr">FnPtr</a></li><li><a href="#variant.Foreign" title="Foreign">Foreign</a></li><li><a href="#variant.Infer" title="Infer">Infer</a></li><li><a href="#variant.Int" title="Int">Int</a></li><li><a href="#variant.Never" title="Never">Never</a></li><li><a href="#variant.Param" title="Param">Param</a></li><li><a href="#variant.Pat" title="Pat">Pat</a></li><li><a href="#variant.Placeholder" title="Placeholder">Placeholder</a></li><li><a href="#variant.RawPtr" title="RawPtr">RawPtr</a></li><li><a href="#variant.Ref" title="Ref">Ref</a></li><li><a href="#variant.Slice" title="Slice">Slice</a></li><li><a href="#variant.Str" title="Str">Str</a></li><li><a href="#variant.Tuple" title="Tuple">Tuple</a></li><li><a href="#variant.Uint" title="Uint">Uint</a></li><li><a href="#variant.UnsafeBinder" title="UnsafeBinder">UnsafeBinder</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hir_<wbr>ty::<wbr>next_<wbr>solver</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">hir_ty</a>::<wbr><a href="index.html">next_solver</a></div><h1>Type Alias <span class="type">TyKind</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/hir_ty/next_solver/ty.rs.html#47">Source</a> </span></div><pre class="rust item-decl"><code>pub type TyKind&lt;'db&gt; = TyKind&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;;</code></pre><h2 id="aliased-type" class="section-header">Aliased Type<a href="#aliased-type" class="anchor">§</a></h2><pre class="rust item-decl"><code>pub enum TyKind&lt;'db&gt; {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 29 variants</span></summary>    Bool,
    Char,
    Int(<a class="enum" href="../primitive/enum.IntTy.html" title="enum hir_ty::primitive::IntTy">IntTy</a>),
    Uint(<a class="enum" href="../primitive/enum.UintTy.html" title="enum hir_ty::primitive::UintTy">UintTy</a>),
    Float(<a class="enum" href="../primitive/enum.FloatTy.html" title="enum hir_ty::primitive::FloatTy">FloatTy</a>),
    Adt(<a class="struct" href="interner/struct.AdtDef.html" title="struct hir_ty::next_solver::interner::AdtDef">AdtDef</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;),
    Foreign(<a class="struct" href="struct.TypeAliasIdWrapper.html" title="struct hir_ty::next_solver::TypeAliasIdWrapper">TypeAliasIdWrapper</a>),
    Str,
    Array(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="struct" href="struct.Const.html" title="struct hir_ty::next_solver::Const">Const</a>&lt;'db&gt;),
    Pat(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="struct" href="interner/struct.Pattern.html" title="struct hir_ty::next_solver::interner::Pattern">Pattern</a>&lt;'db&gt;),
    Slice(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;),
    RawPtr(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="enum" href="enum.Mutability.html" title="enum hir_ty::next_solver::Mutability">Mutability</a>),
    Ref(<a class="struct" href="struct.Region.html" title="struct hir_ty::next_solver::Region">Region</a>&lt;'db&gt;, <a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="enum" href="enum.Mutability.html" title="enum hir_ty::next_solver::Mutability">Mutability</a>),
    FnDef(<a class="struct" href="struct.CallableIdWrapper.html" title="struct hir_ty::next_solver::CallableIdWrapper">CallableIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;),
    FnPtr(Binder&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;, FnSigTys&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;&gt;, FnHeader&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;),
    UnsafeBinder(UnsafeBinderInner&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;),
    Dynamic(<a class="struct" href="predicate/struct.BoundExistentialPredicates.html" title="struct hir_ty::next_solver::predicate::BoundExistentialPredicates">BoundExistentialPredicates</a>&lt;'db&gt;, <a class="struct" href="struct.Region.html" title="struct hir_ty::next_solver::Region">Region</a>&lt;'db&gt;),
    Closure(<a class="struct" href="struct.ClosureIdWrapper.html" title="struct hir_ty::next_solver::ClosureIdWrapper">ClosureIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;),
    CoroutineClosure(<a class="struct" href="struct.CoroutineIdWrapper.html" title="struct hir_ty::next_solver::CoroutineIdWrapper">CoroutineIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;),
    Coroutine(<a class="struct" href="struct.CoroutineIdWrapper.html" title="struct hir_ty::next_solver::CoroutineIdWrapper">CoroutineIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;),
    CoroutineWitness(<a class="struct" href="struct.CoroutineIdWrapper.html" title="struct hir_ty::next_solver::CoroutineIdWrapper">CoroutineIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;),
    Never,
    Tuple(<a class="struct" href="struct.Tys.html" title="struct hir_ty::next_solver::Tys">Tys</a>&lt;'db&gt;),
    Alias(AliasTyKind, AliasTy&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;),
    Param(<a class="struct" href="struct.ParamTy.html" title="struct hir_ty::next_solver::ParamTy">ParamTy</a>),
    Bound(BoundVarIndexKind, <a class="struct" href="struct.BoundTy.html" title="struct hir_ty::next_solver::BoundTy">BoundTy</a>),
    Placeholder(<a class="struct" href="interner/struct.Placeholder.html" title="struct hir_ty::next_solver::interner::Placeholder">Placeholder</a>&lt;<a class="struct" href="struct.BoundTy.html" title="struct hir_ty::next_solver::BoundTy">BoundTy</a>&gt;),
    Infer(InferTy),
    Error(<a class="struct" href="struct.ErrorGuaranteed.html" title="struct hir_ty::next_solver::ErrorGuaranteed">ErrorGuaranteed</a>),
</details>}</code></pre><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.Bool" class="variant"><a href="#variant.Bool" class="anchor">§</a><h3 class="code-header">Bool</h3></section><div class="docblock"><p>The primitive boolean type. Written as <code>bool</code>.</p>
</div><section id="variant.Char" class="variant"><a href="#variant.Char" class="anchor">§</a><h3 class="code-header">Char</h3></section><div class="docblock"><p>The primitive character type; holds a Unicode scalar value
(a non-surrogate code point). Written as <code>char</code>.</p>
</div><section id="variant.Int" class="variant"><a href="#variant.Int" class="anchor">§</a><h3 class="code-header">Int(<a class="enum" href="../primitive/enum.IntTy.html" title="enum hir_ty::primitive::IntTy">IntTy</a>)</h3></section><div class="docblock"><p>A primitive signed integer type. For example, <code>i32</code>.</p>
</div><section id="variant.Uint" class="variant"><a href="#variant.Uint" class="anchor">§</a><h3 class="code-header">Uint(<a class="enum" href="../primitive/enum.UintTy.html" title="enum hir_ty::primitive::UintTy">UintTy</a>)</h3></section><div class="docblock"><p>A primitive unsigned integer type. For example, <code>u32</code>.</p>
</div><section id="variant.Float" class="variant"><a href="#variant.Float" class="anchor">§</a><h3 class="code-header">Float(<a class="enum" href="../primitive/enum.FloatTy.html" title="enum hir_ty::primitive::FloatTy">FloatTy</a>)</h3></section><div class="docblock"><p>A primitive floating-point type. For example, <code>f64</code>.</p>
</div><section id="variant.Adt" class="variant"><a href="#variant.Adt" class="anchor">§</a><h3 class="code-header">Adt(<a class="struct" href="interner/struct.AdtDef.html" title="struct hir_ty::next_solver::interner::AdtDef">AdtDef</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>Algebraic data types (ADT). For example: structures, enumerations and unions.</p>
<p>For example, the type <code>List&lt;i32&gt;</code> would be represented using the <code>AdtDef</code>
for <code>struct List&lt;T&gt;</code> and the args <code>[i32]</code>.</p>
<p>Note that generic parameters in fields only get lazily instantiated
by using something like <code>adt_def.all_fields().map(|field| field.ty(interner, args))</code>.</p>
</div><section id="variant.Foreign" class="variant"><a href="#variant.Foreign" class="anchor">§</a><h3 class="code-header">Foreign(<a class="struct" href="struct.TypeAliasIdWrapper.html" title="struct hir_ty::next_solver::TypeAliasIdWrapper">TypeAliasIdWrapper</a>)</h3></section><div class="docblock"><p>An unsized FFI type that is opaque to Rust. Written as <code>extern type T</code>.</p>
</div><section id="variant.Str" class="variant"><a href="#variant.Str" class="anchor">§</a><h3 class="code-header">Str</h3></section><div class="docblock"><p>The pointee of a string slice. Written as <code>str</code>.</p>
</div><section id="variant.Array" class="variant"><a href="#variant.Array" class="anchor">§</a><h3 class="code-header">Array(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="struct" href="struct.Const.html" title="struct hir_ty::next_solver::Const">Const</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>An array with the given length. Written as <code>[T; N]</code>.</p>
</div><section id="variant.Pat" class="variant"><a href="#variant.Pat" class="anchor">§</a><h3 class="code-header">Pat(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="struct" href="interner/struct.Pattern.html" title="struct hir_ty::next_solver::interner::Pattern">Pattern</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>A pattern newtype. Takes any type and restricts its valid values to its pattern.
This will also change the layout to take advantage of this restriction.
Only <code>Copy</code> and <code>Clone</code> will automatically get implemented for pattern types.
Auto-traits treat this as if it were an aggregate with a single nested type.
Only supports integer range patterns for now.</p>
</div><section id="variant.Slice" class="variant"><a href="#variant.Slice" class="anchor">§</a><h3 class="code-header">Slice(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>The pointee of an array slice. Written as <code>[T]</code>.</p>
</div><section id="variant.RawPtr" class="variant"><a href="#variant.RawPtr" class="anchor">§</a><h3 class="code-header">RawPtr(<a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="enum" href="enum.Mutability.html" title="enum hir_ty::next_solver::Mutability">Mutability</a>)</h3></section><div class="docblock"><p>A raw pointer. Written as <code>*mut T</code> or <code>*const T</code></p>
</div><section id="variant.Ref" class="variant"><a href="#variant.Ref" class="anchor">§</a><h3 class="code-header">Ref(<a class="struct" href="struct.Region.html" title="struct hir_ty::next_solver::Region">Region</a>&lt;'db&gt;, <a class="struct" href="struct.Ty.html" title="struct hir_ty::next_solver::Ty">Ty</a>&lt;'db&gt;, <a class="enum" href="enum.Mutability.html" title="enum hir_ty::next_solver::Mutability">Mutability</a>)</h3></section><div class="docblock"><p>A reference; a pointer with an associated lifetime. Written as
<code>&amp;'a mut T</code> or <code>&amp;'a T</code>.</p>
</div><section id="variant.FnDef" class="variant"><a href="#variant.FnDef" class="anchor">§</a><h3 class="code-header">FnDef(<a class="struct" href="struct.CallableIdWrapper.html" title="struct hir_ty::next_solver::CallableIdWrapper">CallableIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>The anonymous type of a function declaration/definition. Each
function has a unique type.</p>
<p>For the function <code>fn foo() -&gt; i32 { 3 }</code> this type would be
shown to the user as <code>fn() -&gt; i32 {foo}</code>.</p>
<p>For example the type of <code>bar</code> here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>foo() -&gt; i32 { <span class="number">1 </span>}
<span class="kw">let </span>bar = foo; <span class="comment">// bar: fn() -&gt; i32 {foo}</span></code></pre></div></div><section id="variant.FnPtr" class="variant"><a href="#variant.FnPtr" class="anchor">§</a><h3 class="code-header">FnPtr(Binder&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;, FnSigTys&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;&gt;, FnHeader&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;)</h3></section><div class="docblock"><p>A pointer to a function. Written as <code>fn() -&gt; i32</code>.</p>
<p>Note that both functions and closures start out as either
[FnDef] or [Closure] which can be then be coerced to this variant.</p>
<p>For example the type of <code>bar</code> here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>foo() -&gt; i32 { <span class="number">1 </span>}
<span class="kw">let </span>bar: <span class="kw">fn</span>() -&gt; i32 = foo;</code></pre></div>
<p>These two fields are equivalent to a <code>ty::Binder&lt;I, FnSig&lt;I&gt;&gt;</code>. But by
splitting that into two pieces, we get a more compact data layout that
reduces the size of <code>TyKind</code> by 8 bytes. It is a very hot type, so it’s
worth the mild inconvenience.</p>
</div><section id="variant.UnsafeBinder" class="variant"><a href="#variant.UnsafeBinder" class="anchor">§</a><h3 class="code-header">UnsafeBinder(UnsafeBinderInner&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;)</h3></section><div class="docblock"><p>An unsafe binder type.</p>
<p>A higher-ranked type used to represent a type which has had some of its
lifetimes erased. This can be used to represent types in positions where
a lifetime is literally inexpressible, such as self-referential types.</p>
</div><section id="variant.Dynamic" class="variant"><a href="#variant.Dynamic" class="anchor">§</a><h3 class="code-header">Dynamic(<a class="struct" href="predicate/struct.BoundExistentialPredicates.html" title="struct hir_ty::next_solver::predicate::BoundExistentialPredicates">BoundExistentialPredicates</a>&lt;'db&gt;, <a class="struct" href="struct.Region.html" title="struct hir_ty::next_solver::Region">Region</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>A trait object. Written as <code>dyn for&lt;'b&gt; Trait&lt;'b, Assoc = u32&gt; + Send + 'a</code>.</p>
</div><section id="variant.Closure" class="variant"><a href="#variant.Closure" class="anchor">§</a><h3 class="code-header">Closure(<a class="struct" href="struct.ClosureIdWrapper.html" title="struct hir_ty::next_solver::ClosureIdWrapper">ClosureIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>The anonymous type of a closure. Used to represent the type of <code>|a| a</code>.</p>
<p>Closure args contain both the - potentially instantiated - generic parameters
of its parent and some synthetic parameters. See the documentation for
<code>ClosureArgs</code> for more details.</p>
</div><section id="variant.CoroutineClosure" class="variant"><a href="#variant.CoroutineClosure" class="anchor">§</a><h3 class="code-header">CoroutineClosure(<a class="struct" href="struct.CoroutineIdWrapper.html" title="struct hir_ty::next_solver::CoroutineIdWrapper">CoroutineIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>The anonymous type of a closure. Used to represent the type of <code>async |a| a</code>.</p>
<p>Coroutine-closure args contain both the - potentially instantiated - generic
parameters of its parent and some synthetic parameters. See the documentation
for <code>CoroutineClosureArgs</code> for more details.</p>
</div><section id="variant.Coroutine" class="variant"><a href="#variant.Coroutine" class="anchor">§</a><h3 class="code-header">Coroutine(<a class="struct" href="struct.CoroutineIdWrapper.html" title="struct hir_ty::next_solver::CoroutineIdWrapper">CoroutineIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>The anonymous type of a coroutine. Used to represent the type of
<code>|a| yield a</code>.</p>
<p>For more info about coroutine args, visit the documentation for
<code>CoroutineArgs</code>.</p>
</div><section id="variant.CoroutineWitness" class="variant"><a href="#variant.CoroutineWitness" class="anchor">§</a><h3 class="code-header">CoroutineWitness(<a class="struct" href="struct.CoroutineIdWrapper.html" title="struct hir_ty::next_solver::CoroutineIdWrapper">CoroutineIdWrapper</a>, <a class="struct" href="struct.GenericArgs.html" title="struct hir_ty::next_solver::GenericArgs">GenericArgs</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>A type representing the types stored inside a coroutine.
This should only appear as part of the <code>CoroutineArgs</code>.</p>
<p>Unlike upvars, the witness can reference lifetimes from
inside of the coroutine itself. To deal with them in
the type of the coroutine, we convert them to higher ranked
lifetimes bound by the witness itself.</p>
<p>This contains the <code>DefId</code> and the <code>GenericArgsRef</code> of the coroutine.
The actual witness types are computed on MIR by the <code>mir_coroutine_witnesses</code> query.</p>
<p>Looking at the following example, the witness for this coroutine
may end up as something like <code>for&lt;'a&gt; [Vec&lt;i32&gt;, &amp;'a Vec&lt;i32&gt;]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(coroutines)]
#[coroutine] </span><span class="kw">static </span>|a| {
    <span class="kw">let </span>x = <span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">3</span>];
    <span class="kw">yield </span>a;
    <span class="kw">yield </span>x[<span class="number">0</span>];
}</code></pre></div></div><section id="variant.Never" class="variant"><a href="#variant.Never" class="anchor">§</a><h3 class="code-header">Never</h3></section><div class="docblock"><p>The never type <code>!</code>.</p>
</div><section id="variant.Tuple" class="variant"><a href="#variant.Tuple" class="anchor">§</a><h3 class="code-header">Tuple(<a class="struct" href="struct.Tys.html" title="struct hir_ty::next_solver::Tys">Tys</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>A tuple type. For example, <code>(i32, bool)</code>.</p>
</div><section id="variant.Alias" class="variant"><a href="#variant.Alias" class="anchor">§</a><h3 class="code-header">Alias(AliasTyKind, AliasTy&lt;<a class="struct" href="interner/struct.DbInterner.html" title="struct hir_ty::next_solver::interner::DbInterner">DbInterner</a>&lt;'db&gt;&gt;)</h3></section><div class="docblock"><p>A projection, opaque type, free type alias, or inherent associated type.
All of these types are represented as pairs of def-id and args, and can
be normalized, so they are grouped conceptually.</p>
</div><section id="variant.Param" class="variant"><a href="#variant.Param" class="anchor">§</a><h3 class="code-header">Param(<a class="struct" href="struct.ParamTy.html" title="struct hir_ty::next_solver::ParamTy">ParamTy</a>)</h3></section><div class="docblock"><p>A type parameter; for example, <code>T</code> in <code>fn f&lt;T&gt;(x: T) {}</code>.</p>
</div><section id="variant.Bound" class="variant"><a href="#variant.Bound" class="anchor">§</a><h3 class="code-header">Bound(BoundVarIndexKind, <a class="struct" href="struct.BoundTy.html" title="struct hir_ty::next_solver::BoundTy">BoundTy</a>)</h3></section><div class="docblock"><p>Bound type variable, used to represent the <code>'a</code> in <code>for&lt;'a&gt; fn(&amp;'a ())</code>.</p>
<p>For canonical queries, we replace inference variables with bound variables,
so e.g. when checking whether <code>&amp;'_ (): Trait&lt;_&gt;</code> holds, we canonicalize that to
<code>for&lt;'a, T&gt; &amp;'a (): Trait&lt;T&gt;</code> and then convert the introduced bound variables
back to inference variables in a new inference context when inside of the query.</p>
<p>It is conventional to render anonymous bound types like <code>^N</code> or <code>^D_N</code>,
where <code>N</code> is the bound variable’s anonymous index into the binder, and
<code>D</code> is the debruijn index, or totally omitted if the debruijn index is zero.</p>
<p>See the <code>rustc-dev-guide</code> for more details about
<a href="https://rustc-dev-guide.rust-lang.org/traits/hrtb.html">higher-ranked trait bounds</a> and <a href="https://rustc-dev-guide.rust-lang.org/traits/canonical-queries.html">canonical queries</a>.</p>
</div><section id="variant.Placeholder" class="variant"><a href="#variant.Placeholder" class="anchor">§</a><h3 class="code-header">Placeholder(<a class="struct" href="interner/struct.Placeholder.html" title="struct hir_ty::next_solver::interner::Placeholder">Placeholder</a>&lt;<a class="struct" href="struct.BoundTy.html" title="struct hir_ty::next_solver::BoundTy">BoundTy</a>&gt;)</h3></section><div class="docblock"><p>A placeholder type, used during higher ranked subtyping to instantiate
bound variables.</p>
<p>It is conventional to render anonymous placeholder types like <code>!N</code> or <code>!U_N</code>,
where <code>N</code> is the placeholder variable’s anonymous index (which corresponds
to the bound variable’s index from the binder from which it was instantiated),
and <code>U</code> is the universe index in which it is instantiated, or totally omitted
if the universe index is zero.</p>
</div><section id="variant.Infer" class="variant"><a href="#variant.Infer" class="anchor">§</a><h3 class="code-header">Infer(InferTy)</h3></section><div class="docblock"><p>A type variable used during type checking.</p>
<p>Similar to placeholders, inference variables also live in a universe to
correctly deal with higher ranked types. Though unlike placeholders,
that universe is stored in the <code>InferCtxt</code> instead of directly
inside of the type.</p>
</div><section id="variant.Error" class="variant"><a href="#variant.Error" class="anchor">§</a><h3 class="code-header">Error(<a class="struct" href="struct.ErrorGuaranteed.html" title="struct hir_ty::next_solver::ErrorGuaranteed">ErrorGuaranteed</a>)</h3></section><div class="docblock"><p>A placeholder for a type which could not be computed; this is
propagated to avoid useless error messages.</p>
</div></div><script src="../../type.impl/ra_ap_rustc_type_ir/ty_kind/enum.TyKind.js" data-self-path="hir_ty::next_solver::ty::TyKind" async></script></section></div></main></body></html>