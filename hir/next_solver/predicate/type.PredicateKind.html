<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `PredicateKind` type in crate `hir`."><title>PredicateKind in hir::next_solver::predicate - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="hir" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">PredicateKind</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../hir/index.html">hir</a><span class="version">0.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Predicate<wbr>Kind</a></h2><h3><a href="#aliased-type">Aliased Type</a></h3><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.AliasRelate" title="AliasRelate">AliasRelate</a></li><li><a href="#variant.Ambiguous" title="Ambiguous">Ambiguous</a></li><li><a href="#variant.Clause" title="Clause">Clause</a></li><li><a href="#variant.Coerce" title="Coerce">Coerce</a></li><li><a href="#variant.ConstEquate" title="ConstEquate">ConstEquate</a></li><li><a href="#variant.DynCompatible" title="DynCompatible">DynCompatible</a></li><li><a href="#variant.NormalizesTo" title="NormalizesTo">NormalizesTo</a></li><li><a href="#variant.Subtype" title="Subtype">Subtype</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hir::<wbr>next_<wbr>solver::<wbr>predicate</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">hir</a>::<wbr><a href="../index.html">next_solver</a>::<wbr><a href="index.html">predicate</a></div><h1>Type Alias <span class="type">Predicate<wbr>Kind</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub type PredicateKind&lt;'db&gt; = PredicateKind&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;;</code></pre><h2 id="aliased-type" class="section-header">Aliased Type<a href="#aliased-type" class="anchor">§</a></h2><pre class="rust item-decl"><code>pub enum PredicateKind&lt;'db&gt; {
    Clause(ClauseKind&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;),
    DynCompatible(<a class="struct" href="../struct.TraitIdWrapper.html" title="struct hir::next_solver::TraitIdWrapper">TraitIdWrapper</a>),
    Subtype(SubtypePredicate&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;),
    Coerce(CoercePredicate&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;),
    ConstEquate(<a class="struct" href="../struct.Const.html" title="struct hir::next_solver::Const">Const</a>&lt;'db&gt;, <a class="struct" href="../struct.Const.html" title="struct hir::next_solver::Const">Const</a>&lt;'db&gt;),
    Ambiguous,
    NormalizesTo(NormalizesTo&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;),
    AliasRelate(<a class="enum" href="../enum.Term.html" title="enum hir::next_solver::Term">Term</a>&lt;'db&gt;, <a class="enum" href="../enum.Term.html" title="enum hir::next_solver::Term">Term</a>&lt;'db&gt;, AliasRelationDirection),
}</code></pre><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.Clause" class="variant"><a href="#variant.Clause" class="anchor">§</a><h3 class="code-header">Clause(ClauseKind&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;)</h3></section><div class="docblock"><p>Prove a clause</p>
</div><section id="variant.DynCompatible" class="variant"><a href="#variant.DynCompatible" class="anchor">§</a><h3 class="code-header">DynCompatible(<a class="struct" href="../struct.TraitIdWrapper.html" title="struct hir::next_solver::TraitIdWrapper">TraitIdWrapper</a>)</h3></section><div class="docblock"><p>Trait must be dyn-compatible.</p>
</div><section id="variant.Subtype" class="variant"><a href="#variant.Subtype" class="anchor">§</a><h3 class="code-header">Subtype(SubtypePredicate&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;)</h3></section><div class="docblock"><p><code>T1 &lt;: T2</code></p>
<p>This obligation is created most often when we have two
unresolved type variables and hence don’t have enough
information to process the subtyping obligation yet.</p>
</div><section id="variant.Coerce" class="variant"><a href="#variant.Coerce" class="anchor">§</a><h3 class="code-header">Coerce(CoercePredicate&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;)</h3></section><div class="docblock"><p><code>T1</code> coerced to <code>T2</code></p>
<p>Like a subtyping obligation, this is created most often
when we have two unresolved type variables and hence
don’t have enough information to process the coercion
obligation yet. At the moment, we actually process coercions
very much like subtyping and don’t handle the full coercion
logic.</p>
</div><section id="variant.ConstEquate" class="variant"><a href="#variant.ConstEquate" class="anchor">§</a><h3 class="code-header">ConstEquate(<a class="struct" href="../struct.Const.html" title="struct hir::next_solver::Const">Const</a>&lt;'db&gt;, <a class="struct" href="../struct.Const.html" title="struct hir::next_solver::Const">Const</a>&lt;'db&gt;)</h3></section><div class="docblock"><p>Constants must be equal. The first component is the const that is expected.</p>
</div><section id="variant.Ambiguous" class="variant"><a href="#variant.Ambiguous" class="anchor">§</a><h3 class="code-header">Ambiguous</h3></section><div class="docblock"><p>A marker predicate that is always ambiguous.
Used for coherence to mark opaque types as possibly equal to each other but ambiguous.</p>
</div><section id="variant.NormalizesTo" class="variant"><a href="#variant.NormalizesTo" class="anchor">§</a><h3 class="code-header">NormalizesTo(NormalizesTo&lt;<a class="struct" href="../struct.DbInterner.html" title="struct hir::next_solver::DbInterner">DbInterner</a>&lt;'db&gt;&gt;)</h3></section><div class="docblock"><p>This should only be used inside of the new solver for <code>AliasRelate</code> and expects
the <code>term</code> to be always be an unconstrained inference variable. It is used to
normalize <code>alias</code> as much as possible. In case the alias is rigid - i.e. it cannot
be normalized in the current environment - this constrains <code>term</code> to be equal to
the alias itself.</p>
<p>It is likely more useful to think of this as a function <code>normalizes_to(alias)</code>,
whose return value is written into <code>term</code>.</p>
</div><section id="variant.AliasRelate" class="variant"><a href="#variant.AliasRelate" class="anchor">§</a><h3 class="code-header">AliasRelate(<a class="enum" href="../enum.Term.html" title="enum hir::next_solver::Term">Term</a>&lt;'db&gt;, <a class="enum" href="../enum.Term.html" title="enum hir::next_solver::Term">Term</a>&lt;'db&gt;, AliasRelationDirection)</h3></section><div class="docblock"><p>Separate from <code>ClauseKind::Projection</code> which is used for normalization in new solver.
This predicate requires two terms to be equal to eachother.</p>
<p>Only used for new solver.</p>
</div></div><script src="../../../type.impl/ra_ap_rustc_type_ir/predicate_kind/enum.PredicateKind.js" data-self-path="hir::next_solver::PredicateKind" async></script></section></div></main></body></html>