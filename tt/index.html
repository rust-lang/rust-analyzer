<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`tt` crate defines a `TokenTree` data structure: this is the interface (both input and output) of macros."><title>tt - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tt" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.1 (01f6ddf75 2026-02-11)" data-channel="1.93.1" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate tt</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../tt/index.html">tt</a><span class="version">0.0.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>tt</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/tt/lib.rs.html#1-910">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>tt</code> crate defines a <code>TokenTree</code> data structure: this is the interface (both
input and output) of macros.</p>
<p>The <code>TokenTree</code> is semantically a tree, but for performance reasons it is stored as a flat structure.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">Â§</a></h2><dl class="item-table reexports"><dt id="reexport.TtElement"><code>pub use self::iter::<a class="enum" href="iter/enum.TtElement.html" title="enum tt::iter::TtElement">TtElement</a>;</code></dt><dt id="reexport.TtIter"><code>pub use self::iter::<a class="struct" href="iter/struct.TtIter.html" title="struct tt::iter::TtIter">TtIter</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="buffer/index.html" title="mod tt::buffer">buffer</a></dt><dd>Stateful iteration over token trees.</dd><dt><a class="mod" href="iter/index.html" title="mod tt::iter">iter</a></dt><dd>A â€œParserâ€ structure for token trees. We use this when parsing a declarative
macro definition into a list of patterns and templates.</dd><dt><a class="mod" href="storage/index.html" title="mod tt::storage">storage</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Spans are memory heavy, and we have a lot of token trees. Storing them straight
will waste a lot of memory. So instead we implement a clever compression mechanism:</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.dispatch_ref.html" title="macro tt::dispatch_ref">dispatch_<wbr>ref</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.DelimSpan.html" title="struct tt::DelimSpan">Delim<wbr>Span</a></dt><dt><a class="struct" href="struct.Delimiter.html" title="struct tt::Delimiter">Delimiter</a></dt><dt><a class="struct" href="struct.Ident.html" title="struct tt::Ident">Ident</a></dt><dd>Identifier or keyword.</dd><dt><a class="struct" href="struct.Lit.html" title="struct tt::Lit">Lit</a></dt><dt><a class="struct" href="struct.Literal.html" title="struct tt::Literal">Literal</a></dt><dt><a class="struct" href="struct.Punct.html" title="struct tt::Punct">Punct</a></dt><dt><a class="struct" href="struct.Span.html" title="struct tt::Span">Span</a></dt><dd>Spans represent a region of code, used by the IDE to be able link macro inputs and outputs
together. Positions in spans are relative to some [<code>SpanAnchor</code>] to make them more incremental
friendly.</dd><dt><a class="struct" href="struct.Subtree.html" title="struct tt::Subtree">Subtree</a></dt><dt><a class="struct" href="struct.SubtreeView.html" title="struct tt::SubtreeView">Subtree<wbr>View</a></dt><dt><a class="struct" href="struct.TextRange.html" title="struct tt::TextRange">Text<wbr>Range</a></dt><dd>A range in text, represented as a pair of <a href="struct.TextSize.html" title="struct tt::TextSize"><code>TextSize</code></a>.</dd><dt><a class="struct" href="struct.TextSize.html" title="struct tt::TextSize">Text<wbr>Size</a></dt><dd>A measure of text length. Also, equivalently, an index into text.</dd><dt><a class="struct" href="struct.TokenTreesView.html" title="struct tt::TokenTreesView">Token<wbr>Trees<wbr>View</a></dt><dt><a class="struct" href="struct.TopSubtree.html" title="struct tt::TopSubtree">TopSubtree</a></dt><dt><a class="struct" href="struct.TopSubtreeBuilder.html" title="struct tt::TopSubtreeBuilder">TopSubtree<wbr>Builder</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.DelimiterKind.html" title="enum tt::DelimiterKind">Delimiter<wbr>Kind</a></dt><dt><a class="enum" href="enum.IdentIsRaw.html" title="enum tt::IdentIsRaw">Ident<wbr>IsRaw</a></dt><dt><a class="enum" href="enum.Leaf.html" title="enum tt::Leaf">Leaf</a></dt><dt><a class="enum" href="enum.LitKind.html" title="enum tt::LitKind">LitKind</a></dt><dt><a class="enum" href="enum.Spacing.html" title="enum tt::Spacing">Spacing</a></dt><dd>Indicates whether a token can join with the following token to form a
compound token. Used for conversions to <code>proc_macro::Spacing</code>. Also used to
guide pretty-printing, which is where the <code>JointHidden</code> value (which isnâ€™t
part of <code>proc_macro::Spacing</code>) comes in useful.</dd><dt><a class="enum" href="enum.TokenTree.html" title="enum tt::TokenTree">Token<wbr>Tree</a></dt><dt><a class="enum" href="enum.TokenTreesReprRef.html" title="enum tt::TokenTreesReprRef">Token<wbr>Trees<wbr>Repr<wbr>Ref</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="enum" href="enum.TransformTtAction.html" title="enum tt::TransformTtAction">Transform<wbr>TtAction</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.MAX_GLUED_PUNCT_LEN.html" title="constant tt::MAX_GLUED_PUNCT_LEN">MAX_<wbr>GLUED_<wbr>PUNCT_<wbr>LEN</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.pretty.html" title="fn tt::pretty">pretty</a></dt><dt><a class="fn" href="fn.print_debug_subtree.html" title="fn tt::print_debug_subtree">print_<wbr>debug_<wbr>subtree</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.print_debug_token.html" title="fn tt::print_debug_token">print_<wbr>debug_<wbr>token</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.token_to_literal.html" title="fn tt::token_to_literal">token_<wbr>to_<wbr>literal</a></dt><dt><a class="fn" href="fn.transform_tt.html" title="fn tt::transform_tt">transform_<wbr>tt</a></dt><dd>This function takes a token tree, and calls <code>callback</code> with each token tree in it.
Then it does what the callback says: keeps the tt or replaces it with a (possibly empty)
tts view.</dd></dl></section></div></main></body></html>